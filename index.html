<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Web画面合成ツール (OBS風)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', 'Noto Sans JP', sans-serif;
        }
        .placeholder-bg {
            background-image:
                linear-gradient(45deg, #2d3748 25%, transparent 25%),
                linear-gradient(-45deg, #2d3748 25%, transparent 25%),
                linear-gradient(45deg, transparent 75%, #2d3748 75%),
                linear-gradient(-45deg, transparent 75%, #2d3748 75%);
            background-size: 20px 20px;
            background-position: 0 0, 0 10px, 10px -10px, -10px 0px;
        }
        /* プレゼンテーションモード用のスタイル */
        body.presentation-mode {
            overflow: hidden; /* スクロールバーを隠す */
        }
        body.presentation-mode .hide-in-presentation {
            display: none !important; /* このクラスを持つUI要素を非表示 */
        }
        body.presentation-mode #canvas-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            z-index: 1000;
            border-radius: 0;
            border: none;
        }
        body.presentation-mode #togglePresentationMode {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 1001;
            opacity: 0.15;
            transition: opacity 0.3s ease-in-out;
        }
        body.presentation-mode #togglePresentationMode:hover {
            opacity: 1;
        }
    </style>
</head>
<body class="bg-gray-900 text-white flex flex-col min-h-screen">

    <main class="flex-grow container mx-auto p-4 md:p-6">
        <!-- ヘッダー -->
        <div class="text-center mb-6 hide-in-presentation">
            <h1 class="text-3xl md:text-4xl font-bold">Web画面合成ツール (OBS風)</h1>
            <p class="text-gray-400 mt-2">インストール不要。2つの画面やカメラを1つに合成し、Google Meetで共有できます。</p>
        </div>

        <!-- 使い方 -->
        <div class="bg-gray-800 border border-gray-700 p-4 rounded-lg mb-6 max-w-4xl mx-auto hide-in-presentation">
            <h2 class="text-xl font-semibold mb-3 flex items-center">
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="mr-2"><circle cx="12" cy="12" r="10"></circle><line x1="12" y1="16" x2="12" y2="12"></line><line x1="12" y1="8" x2="12.01" y2="8"></line></svg>
                使い方
            </h2>
            <ol class="list-decimal list-inside space-y-2 text-gray-300">
                <li><strong class="text-yellow-400">重要:</strong> このツールは、<strong class="text-yellow-400">他のウィンドウを合成するための舞台</strong>です。ソース選択時に、このツール自体のタブは選ばないでください。</li>
                <li>下の「ソース1」「ソース2」で、共有したい<strong class="text-yellow-400">別の</strong>アプリやブラウザタブを選択します。</li>
                <li>レイアウトを選び、中央のプレビューに映像が合成されていることを確認します。</li>
                <li>Google Meetで画面共有を開始し、「<strong>タブを共有</strong>」から「<strong class="text-teal-400">Web画面合成ツール (OBS風)</strong>」を選んでください。</li>
            </ol>
        </div>
        
        <!-- レイアウト選択 -->
        <div class="flex justify-center items-center gap-4 mb-6 hide-in-presentation">
            <h3 class="text-lg font-semibold">レイアウト:</h3>
            <button id="layout-side-by-side" class="bg-gray-700 hover:bg-teal-600 border-2 border-teal-500 text-white font-bold py-2 px-4 rounded-md transition-colors duration-200">左右分割</button>
            <button id="layout-pip" class="bg-gray-700 hover:bg-teal-600 border-2 border-gray-700 text-white font-bold py-2 px-4 rounded-md transition-colors duration-200">小窓 (PiP)</button>
        </div>

        <!-- メインコンテンツ -->
        <div class="flex flex-col lg:flex-row items-center justify-center gap-4">
            
            <!-- ソース1 コントロール -->
            <div class="w-full lg:w-1/5 bg-gray-800 p-4 rounded-lg flex flex-col items-center justify-center space-y-3 hide-in-presentation">
                <h3 class="text-lg font-bold">ソース1</h3>
                <button id="selectScreen1" class="w-full bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded-md transition-colors duration-200">画面を選択</button>
                <button id="selectCamera1" class="w-full bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-2 px-4 rounded-md transition-colors duration-200">カメラを選択</button>
                <button id="reset1" class="w-full bg-red-600 hover:bg-red-700 text-white font-bold py-2 px-4 rounded-md transition-colors duration-200 mt-2">リセット</button>
                <p id="status1" class="text-sm text-gray-400 h-4 mt-1">未選択</p>
            </div>

            <!-- 合成プレビュー -->
            <div id="canvas-container" class="w-full lg:w-3/5 aspect-video bg-black rounded-lg shadow-2xl border-2 border-gray-700 overflow-hidden">
                <canvas id="compositeCanvas" class="w-full h-full placeholder-bg"></canvas>
            </div>

            <!-- ソース2 コントロール -->
            <div class="w-full lg:w-1/5 bg-gray-800 p-4 rounded-lg flex flex-col items-center justify-center space-y-3 hide-in-presentation">
                <h3 class="text-lg font-bold">ソース2</h3>
                <button id="selectScreen2" class="w-full bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded-md transition-colors duration-200">画面を選択</button>
                <button id="selectCamera2" class="w-full bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-2 px-4 rounded-md transition-colors duration-200">カメラを選択</button>
                <button id="reset2" class="w-full bg-red-600 hover:bg-red-700 text-white font-bold py-2 px-4 rounded-md transition-colors duration-200 mt-2">リセット</button>
                <p id="status2" class="text-sm text-gray-400 h-4 mt-1">未選択</p>
            </div>
        </div>

         <!-- プレゼンテーションモードボタン -->
         <div class="flex justify-center mt-6 hide-in-presentation">
             <button id="togglePresentationMode" class="bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-4 rounded-md transition-colors duration-200 flex items-center">
                <svg id="presentation-icon-expand" xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="inline-block mr-2"><path d="M8 3H5a2 2 0 0 0-2 2v3m18 0V5a2 2 0 0 0-2-2h-3m0 18h3a2 2 0 0 0 2-2v-3M3 16v3a2 2 0 0 0 2 2h3"></path></svg>
                <svg id="presentation-icon-compress" xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="inline-block mr-2 hidden"><path d="M15 3h6v6m-11 5L21 3m-6 12v6h-6m5-11L3 21"></path></svg>
                <span id="presentationModeText">全画面表示</span>
            </button>
        </div>

        <!-- 診断用パネル (スクロールしても描画が止まらないよう、画面隅に小さく固定表示) -->
        <div class="fixed bottom-0 left-0 w-px h-px opacity-0 pointer-events-none -z-10">
            <video id="source1VideoDebug" playsinline autoplay muted></video>
            <video id="source2VideoDebug" playsinline autoplay muted></video>
        </div>

    </main>

    <!-- 初回警告モーダル -->
    <div id="firstTimeWarningModal" class="fixed inset-0 bg-black bg-opacity-75 flex items-center justify-center hidden z-50 p-4">
        <div class="bg-gray-800 rounded-lg shadow-2xl p-6 max-w-lg w-full mx-auto border border-yellow-500">
            <h3 class="text-xl font-bold text-yellow-400 mb-4 flex items-center">
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="mr-2"><path d="M10.29 3.86L1.82 18a2 2 0 0 0 1.71 3h16.94a2 2 0 0 0 1.71-3L13.71 3.86a2 2 0 0 0-3.42 0z"></path><line x1="12" y1="9" x2="12" y2="13"></line><line x1="12" y1="17" x2="12.01" y2="17"></line></svg>
                重要な使い方
            </h3>
            <p class="text-gray-300 mb-4">
                このツールは、<strong>他の</strong>ウィンドウやタブを合成するための「舞台」です。
            </p>
            <p class="text-gray-300 mb-6">
                ソースを選択する際、<strong>このツール自体のタブは絶対に選ばないでください。</strong>ブラウザの仕様により、画面が真っ黒になり、正常に動作しません。
            </p>
            <button id="closeWarningModal" class="w-full bg-yellow-600 hover:bg-yellow-700 text-black font-bold py-2 px-4 rounded-md transition-colors duration-200">理解しました</button>
        </div>
    </div>

    <!-- エラーメッセージ用モーダル -->
    <div id="permissionModal" class="fixed inset-0 bg-black bg-opacity-75 flex items-center justify-center hidden z-50 p-4">
        <div class="bg-gray-800 rounded-lg shadow-2xl p-6 max-w-md w-full mx-auto border border-gray-700">
            <h3 class="text-xl font-bold text-red-400 mb-4 flex items-center">
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="mr-2"><path d="M10.29 3.86L1.82 18a2 2 0 0 0 1.71 3h16.94a2 2 0 0 0 1.71-3L13.71 3.86a2 2 0 0 0-3.42 0z"></path><line x1="12" y1="9" x2="12" y2="13"></line><line x1="12" y1="17" x2="12.01" y2="17"></line></svg>
                アクセス権限エラー
            </h3>
            <p class="text-gray-300 mb-4">
                画面共有を開始できませんでした。<br>
                ブラウザの設定で、このページに対する画面キャプチャの権限がブロックされている可能性があります。
            </p>
            <p class="text-gray-300 mb-6">
                このツールが別のページに埋め込まれて動作している場合、埋め込み元のセキュリティポリシーによって機能が制限されていることが原因です。
            </p>
            <button id="closeModal" class="w-full bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded-md transition-colors duration-200">閉じる</button>
        </div>
    </div>
    
    <footer class="text-center text-gray-500 text-sm p-4 hide-in-presentation">
        <p>このツールは、ブラウザの機能のみで動作します。映像データが外部サーバーに送信されることはありません。</p>
    </footer>

    <script>
        const canvas = document.getElementById('compositeCanvas');
        const ctx = canvas.getContext('2d');
        const video1Debug = document.getElementById('source1VideoDebug');
        const video2Debug = document.getElementById('source2VideoDebug');
        const status1 = document.getElementById('status1');
        const status2 = document.getElementById('status2');
        const modal = document.getElementById('permissionModal');
        const closeModalBtn = document.getElementById('closeModal');
        const warningModal = document.getElementById('firstTimeWarningModal');
        const closeWarningModalBtn = document.getElementById('closeWarningModal');
        const layoutSideBySideBtn = document.getElementById('layout-side-by-side');
        const layoutPipBtn = document.getElementById('layout-pip');
        const togglePresentationModeBtn = document.getElementById('togglePresentationMode');
        const presentationModeText = document.getElementById('presentationModeText');
        const iconExpand = document.getElementById('presentation-icon-expand');
        const iconCompress = document.getElementById('presentation-icon-compress');


        let stream1 = null;
        let stream2 = null;
        let currentLayout = 'side-by-side';
        let pendingAction = null;

        canvas.width = 1280;
        canvas.height = 720;
        
        closeModalBtn.addEventListener('click', () => modal.classList.add('hidden'));
        closeWarningModalBtn.addEventListener('click', () => {
            warningModal.classList.add('hidden');
            localStorage.setItem('webObsToolWarningSeen', 'true');
            if (pendingAction) {
                pendingAction();
                pendingAction = null;
            }
        });

        function updateLayoutButtons() {
            if (currentLayout === 'side-by-side') {
                layoutSideBySideBtn.classList.add('border-teal-500');
                layoutSideBySideBtn.classList.remove('border-gray-700');
                layoutPipBtn.classList.add('border-gray-700');
                layoutPipBtn.classList.remove('border-teal-500');
            } else {
                layoutPipBtn.classList.add('border-teal-500');
                layoutPipBtn.classList.remove('border-gray-700');
                layoutSideBySideBtn.classList.add('border-gray-700');
                layoutSideBySideBtn.classList.remove('border-teal-500');
            }
        }

        layoutSideBySideBtn.addEventListener('click', () => {
            currentLayout = 'side-by-side';
            updateLayoutButtons();
        });
        layoutPipBtn.addEventListener('click', () => {
            currentLayout = 'pip';
            updateLayoutButtons();
        });

        document.getElementById('selectScreen1').addEventListener('click', () => triggerSourceSelection('display', 1));
        document.getElementById('selectCamera1').addEventListener('click', () => triggerSourceSelection('user', 1));
        document.getElementById('selectScreen2').addEventListener('click', () => triggerSourceSelection('display', 2));
        document.getElementById('selectCamera2').addEventListener('click', () => triggerSourceSelection('user', 2));

        document.getElementById('reset1').addEventListener('click', () => resetSource(1));
        document.getElementById('reset2').addEventListener('click', () => resetSource(2));

        function triggerSourceSelection(type, sourceNum) {
            const action = () => handleSourceSelection(type, sourceNum);

            if (type === 'display' && !localStorage.getItem('webObsToolWarningSeen')) {
                pendingAction = action;
                warningModal.classList.remove('hidden');
            } else {
                action();
            }
        }

        async function handleSourceSelection(type, sourceNum) {
            try {
                const stream = await navigator.mediaDevices[type === 'display' ? 'getDisplayMedia' : 'getUserMedia']({ video: true, audio: false });
                
                if (sourceNum === 1) {
                    stream1 = stream;
                    video1Debug.srcObject = stream;
                    status1.textContent = type === 'display' ? '画面を選択中' : 'カメラを選択中';
                } else { // sourceNum === 2
                    stream2 = stream;
                    video2Debug.srcObject = stream;
                    status2.textContent = type === 'display' ? '画面を選択中' : 'カメラを選択中';
                }

                stream.getVideoTracks()[0].onended = () => resetSource(sourceNum);
            } catch (err) {
                console.error("Error selecting source:", err);
                if (err.name === 'NotAllowedError') {
                    if(sourceNum === 1) status1.textContent = 'アクセスが拒否されました';
                    else status2.textContent = 'アクセスが拒否されました';
                    modal.classList.remove('hidden');
                } else {
                    if(sourceNum === 1) status1.textContent = '選択失敗';
                    else status2.textContent = '選択失敗';
                }
            }
        }

        function resetSource(sourceNum) {
            if (sourceNum === 1) {
                if (stream1) {
                    stream1.getTracks().forEach(track => track.stop());
                }
                stream1 = null;
                video1Debug.srcObject = null;
                status1.textContent = '未選択';
            } else { // sourceNum === 2
                if (stream2) {
                    stream2.getTracks().forEach(track => track.stop());
                }
                stream2 = null;
                video2Debug.srcObject = null;
                status2.textContent = '未選択';
            }
        }
        
        function getLines(ctx, text, maxWidth) {
            const words = text.split(" ");
            let lines = [];
            if (!words.length) return lines;
            let currentLine = words[0];

            for (let i = 1; i < words.length; i++) {
                const word = words[i];
                const width = ctx.measureText(currentLine + " " + word).width;
                if (width < maxWidth) {
                    currentLine += " " + word;
                } else {
                    lines.push(currentLine);
                    currentLine = word;
                }
            }
            lines.push(currentLine);
            return lines;
        }

        function drawPlaceholder(x, y, w, h, text, isError = false) {
            ctx.fillStyle = isError ? '#5f2120' : '#2d3748';
            ctx.fillRect(x, y, w, h);
            ctx.fillStyle = 'white';
            ctx.font = '20px "Inter"';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            
            const lines = getLines(ctx, text, w - 40);
            const lineHeight = 24;
            const totalHeight = lines.length * lineHeight;
            let startY = y + (h - totalHeight) / 2 + (lineHeight / 2) - 4;

            lines.forEach((line, i) => {
                ctx.fillText(line, x + w / 2, startY + i * lineHeight);
            });
        }

        function drawVideoWithAspectRatio(video, x, y, w, h) {
             if (video.videoWidth === 0 || !video.srcObject) { // !video.srcObject を追加
                 const errorText = "🚫 表示できません。このツール自体を選択していませんか？「リセット」を押して、別のウィンドウを選び直してください。";
                 drawPlaceholder(x, y, w, h, errorText, true);
                 return;
             }
            const videoAspect = video.videoWidth / video.videoHeight;
            const canvasAspect = w / h;
            let drawWidth, drawHeight, offsetX, offsetY;

            if (videoAspect > canvasAspect) {
                drawWidth = w;
                drawHeight = drawWidth / videoaspect;
                offsetX = x;
                offsetY = y + (h - drawHeight) / 2;
            } else {
                drawHeight = h;
                drawWidth = drawHeight * videoAspect;
                offsetX = x + (w - drawWidth) / 2;
                offsetY = y;
            }
            ctx.drawImage(video, offsetX, offsetY, drawWidth, drawHeight);
        }

        function drawCanvas() {
            ctx.fillStyle = '#1a202c';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            if (currentLayout === 'side-by-side') {
                const halfWidth = canvas.width / 2;
                if (stream1) drawVideoWithAspectRatio(video1Debug, 0, 0, halfWidth, canvas.height);
                else drawPlaceholder(0, 0, halfWidth, canvas.height, 'ソース1を選択');
                
                if (stream2) drawVideoWithAspectRatio(video2Debug, halfWidth, 0, halfWidth, canvas.height);
                else drawPlaceholder(halfWidth, 0, halfWidth, canvas.height, 'ソース2を選択');

                ctx.fillStyle = '#4a5568';
                ctx.fillRect(halfWidth - 1, 0, 2, canvas.height);
            } else if (currentLayout === 'pip') {
                const pipWidth = canvas.width * 0.3;
                const pipHeight = pipWidth / (16/9);
                const margin = canvas.width * 0.015;

                if (stream1) drawVideoWithAspectRatio(video1Debug, 0, 0, canvas.width, canvas.height);
                else drawPlaceholder(0, 0, canvas.width, canvas.height, 'ソース1 (背景) を選択');

                if (stream2) {
                    ctx.save();
                    ctx.shadowColor = 'rgba(0, 0, 0, 0.5)';
                    ctx.shadowBlur = 15;
                    drawVideoWithAspectRatio(video2Debug, canvas.width - pipWidth - margin, canvas.height - pipHeight - margin, pipWidth, pipHeight);
                    ctx.strokeStyle = '#4a5568';
                    ctx.lineWidth = 2;
                    ctx.strokeRect(canvas.width - pipWidth - margin, canvas.height - pipHeight - margin, pipWidth, pipHeight);
                    ctx.restore();
                } else {
                     drawPlaceholder(canvas.width - pipWidth - margin, canvas.height - pipHeight - margin, pipWidth, pipHeight, 'ソース2');
                }
            }
            requestAnimationFrame(drawCanvas);
        }
        
        // --- プレゼンテーションモードのロジック ---
        // UIの表示・非表示を制御します
        function updatePresentationModeUI() {
            // bodyに 'presentation-mode' クラスがあるかどうかで表示を切り替える
            if (document.body.classList.contains('presentation-mode')) {
                // --- プレゼンテーションモード（UI非表示） ---
                // CSSによって .hide-in-presentation クラスを持つ要素が非表示になる
                presentationModeText.textContent = '編集に戻る';
                iconExpand.classList.add('hidden');
                iconCompress.classList.remove('hidden');
            } else {
                // --- 通常モード（UI表示） ---
                // CSSのセレクタが一致しなくなり、UI要素が通常通り表示される
                presentationModeText.textContent = '全画面表示';
                iconExpand.classList.remove('hidden');
                iconCompress.classList.add('hidden');
            }
        }

        // 「全画面表示」ボタンがクリックされた時の処理
        togglePresentationModeBtn.addEventListener('click', () => {
            // bodyタグに 'presentation-mode' クラスを付けたり外したりする
            document.body.classList.toggle('presentation-mode');
            // 表示を更新
            updatePresentationModeUI();
        });

        // Escapeキーでプレゼンテーションモードを終了する処理
        document.addEventListener('keydown', (event) => {
            if (event.key === 'Escape' && document.body.classList.contains('presentation-mode')) {
                document.body.classList.remove('presentation-mode');
                updatePresentationModeUI();
            }
        });


        // 初期化処理
        updateLayoutButtons();
        drawCanvas();
    </script>
</body>
</html>

