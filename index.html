<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Web画面合成ツール (OBS風)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', 'Noto Sans JP', sans-serif;
        }
        .placeholder-bg {
            background-image:
                linear-gradient(45deg, #2d3748 25%, transparent 25%),
                linear-gradient(-45deg, #2d3748 25%, transparent 25%),
                linear-gradient(45deg, transparent 75%, #2d3748 75%),
                linear-gradient(-45deg, transparent 75%, #2d3748 75%);
            background-size: 20px 20px;
            background-position: 0 0, 0 10px, 10px -10px, -10px 0px;
        }
    </style>
</head>
<body class="bg-gray-900 text-white flex flex-col min-h-screen">

    <main class="flex-grow container mx-auto p-4 md:p-6">
        <!-- ヘッダー -->
        <div class="text-center mb-6">
            <h1 class="text-3xl md:text-4xl font-bold">Web画面合成ツール (OBS風)</h1>
            <p class="text-gray-400 mt-2">インストール不要。2つの画面やカメラを1つに合成し、Google Meetで共有できます。</p>
        </div>

        <!-- 使い方 -->
        <div class="bg-gray-800 border border-gray-700 p-4 rounded-lg mb-6 max-w-4xl mx-auto">
            <h2 class="text-xl font-semibold mb-3 flex items-center">
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="mr-2"><circle cx="12" cy="12" r="10"></circle><line x1="12" y1="16" x2="12" y2="12"></line><line x1="12" y1="8" x2="12.01" y2="8"></line></svg>
                使い方
            </h2>
            <ol class="list-decimal list-inside space-y-2 text-gray-300">
                <li><strong class="text-yellow-400">重要:</strong> ソースを選択する際、このツール自体のタブ/ウィンドウは選択しないでください。</li>
                <li>下の「ソース1」と「ソース2」で、共有したい<strong class="text-yellow-400">別の</strong>画面（ウィンドウ or タブ）やカメラを選択します。</li>
                <li>レイアウトを選択し、中央のプレビューに合成された映像が表示されることを確認します。</li>
                <li>Google Meetの会議画面に移動し、「画面を共有」から「**タブ**」を選択します。</li>
                <li>タブの一覧から「<strong class="text-teal-400">Web画面合成ツール (OBS風)</strong>」を選んで共有を開始してください。</li>
            </ol>
        </div>
        
        <!-- レイアウト選択 -->
        <div class="flex justify-center items-center gap-4 mb-6">
            <h3 class="text-lg font-semibold">レイアウト:</h3>
            <button id="layout-side-by-side" class="bg-gray-700 hover:bg-teal-600 border-2 border-teal-500 text-white font-bold py-2 px-4 rounded-md transition-colors duration-200">左右分割</button>
            <button id="layout-pip" class="bg-gray-700 hover:bg-teal-600 border-2 border-gray-700 text-white font-bold py-2 px-4 rounded-md transition-colors duration-200">小窓 (PiP)</button>
        </div>


        <!-- メインコンテンツ -->
        <div class="flex flex-col lg:flex-row items-center justify-center gap-4">
            
            <!-- ソース1 コントロール -->
            <div class="w-full lg:w-1/5 bg-gray-800 p-4 rounded-lg flex flex-col items-center justify-center space-y-3">
                <h3 class="text-lg font-bold">ソース1</h3>
                <button id="selectScreen1" class="w-full bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded-md transition-colors duration-200">画面を選択</button>
                <button id="selectCamera1" class="w-full bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-2 px-4 rounded-md transition-colors duration-200">カメラを選択</button>
                <button id="reset1" class="w-full bg-red-600 hover:bg-red-700 text-white font-bold py-2 px-4 rounded-md transition-colors duration-200 mt-2">リセット</button>
                <p id="status1" class="text-sm text-gray-400 h-4 mt-1">未選択</p>
            </div>

            <!-- 合成プレビュー -->
            <div class="w-full lg:w-3/5 aspect-video bg-black rounded-lg shadow-2xl border-2 border-gray-700 overflow-hidden">
                <canvas id="compositeCanvas" class="w-full h-full placeholder-bg"></canvas>
            </div>

            <!-- ソース2 コントロール -->
            <div class="w-full lg:w-1/5 bg-gray-800 p-4 rounded-lg flex flex-col items-center justify-center space-y-3">
                <h3 class="text-lg font-bold">ソース2</h3>
                <button id="selectScreen2" class="w-full bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded-md transition-colors duration-200">画面を選択</button>
                <button id="selectCamera2" class="w-full bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-2 px-4 rounded-md transition-colors duration-200">カメラを選択</button>
                <button id="reset2" class="w-full bg-red-600 hover:bg-red-700 text-white font-bold py-2 px-4 rounded-md transition-colors duration-200 mt-2">リセット</button>
                <p id="status2" class="text-sm text-gray-400 h-4 mt-1">未選択</p>
            </div>
        </div>

        <!-- 内部処理用の非表示ビデオ要素 -->
        <div class="hidden">
            <video id="source1Video" playsinline autoplay muted></video>
            <video id="source2Video" playsinline autoplay muted></video>
        </div>
    </main>

    <!-- エラーメッセージ用モーダル -->
    <div id="permissionModal" class="fixed inset-0 bg-black bg-opacity-75 flex items-center justify-center hidden z-50 p-4">
        <div class="bg-gray-800 rounded-lg shadow-2xl p-6 max-w-md w-full mx-auto border border-gray-700">
            <h3 class="text-xl font-bold text-red-400 mb-4 flex items-center">
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="mr-2"><path d="M10.29 3.86L1.82 18a2 2 0 0 0 1.71 3h16.94a2 2 0 0 0 1.71-3L13.71 3.86a2 2 0 0 0-3.42 0z"></path><line x1="12" y1="9" x2="12" y2="13"></line><line x1="12" y1="17" x2="12.01" y2="17"></line></svg>
                アクセス権限エラー
            </h3>
            <p class="text-gray-300 mb-4">
                画面共有を開始できませんでした。<br>
                ブラウザの設定で、このページに対する画面キャプチャの権限がブロックされている可能性があります。
            </p>
            <p class="text-gray-300 mb-6">
                このツールが別のページに埋め込まれて動作している場合、埋め込み元のセキュリティポリシーによって機能が制限されていることが原因です。
            </p>
            <button id="closeModal" class="w-full bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded-md transition-colors duration-200">閉じる</button>
        </div>
    </div>
    
    <footer class="text-center text-gray-500 text-sm p-4">
        <p>このツールは、ブラウザの機能のみで動作します。映像データが外部サーバーに送信されることはありません。</p>
    </footer>

    <script>
        const canvas = document.getElementById('compositeCanvas');
        const ctx = canvas.getContext('2d');
        const video1 = document.getElementById('source1Video');
        const video2 = document.getElementById('source2Video');
        const status1 = document.getElementById('status1');
        const status2 = document.getElementById('status2');
        const modal = document.getElementById('permissionModal');
        const closeModalBtn = document.getElementById('closeModal');
        const layoutSideBySideBtn = document.getElementById('layout-side-by-side');
        const layoutPipBtn = document.getElementById('layout-pip');

        let stream1 = null;
        let stream2 = null;
        let currentLayout = 'side-by-side';

        canvas.width = 1280;
        canvas.height = 720;
        
        closeModalBtn.addEventListener('click', () => modal.classList.add('hidden'));

        function updateLayoutButtons() {
            if (currentLayout === 'side-by-side') {
                layoutSideBySideBtn.classList.add('border-teal-500');
                layoutSideBySideBtn.classList.remove('border-gray-700');
                layoutPipBtn.classList.add('border-gray-700');
                layoutPipBtn.classList.remove('border-teal-500');
            } else {
                layoutPipBtn.classList.add('border-teal-500');
                layoutPipBtn.classList.remove('border-gray-700');
                layoutSideBySideBtn.classList.add('border-gray-700');
                layoutSideBySideBtn.classList.remove('border-teal-500');
            }
        }

        layoutSideBySideBtn.addEventListener('click', () => {
            currentLayout = 'side-by-side';
            updateLayoutButtons();
        });
        layoutPipBtn.addEventListener('click', () => {
            currentLayout = 'pip';
            updateLayoutButtons();
        });

        document.getElementById('selectScreen1').addEventListener('click', () => handleSourceSelection('display', 1));
        document.getElementById('selectCamera1').addEventListener('click', () => handleSourceSelection('user', 1));
        document.getElementById('selectScreen2').addEventListener('click', () => handleSourceSelection('display', 2));
        document.getElementById('selectCamera2').addEventListener('click', () => handleSourceSelection('user', 2));

        document.getElementById('reset1').addEventListener('click', () => resetSource(1));
        document.getElementById('reset2').addEventListener('click', () => resetSource(2));

        async function handleSourceSelection(type, sourceNum) {
            const video = (sourceNum === 1) ? video1 : video2;
            const status = (sourceNum === 1) ? status1 : status2;
            
            try {
                const stream = await navigator.mediaDevices[type === 'display' ? 'getDisplayMedia' : 'getUserMedia']({ video: true, audio: false });
                
                if (sourceNum === 1) stream1 = stream;
                else stream2 = stream;

                video.srcObject = stream;
                status.textContent = type === 'display' ? '画面を選択中' : 'カメラを選択中';

                stream.getVideoTracks()[0].onended = () => resetSource(sourceNum);
            } catch (err) {
                console.error("Error selecting source:", err);
                if (err.name === 'NotAllowedError') {
                    status.textContent = 'アクセスが拒否されました';
                    modal.classList.remove('hidden');
                } else {
                    status.textContent = '選択失敗';
                }
            }
        }

        function resetSource(sourceNum) {
            const video = (sourceNum === 1) ? video1 : video2;
            const status = (sourceNum === 1) ? status1 : status2;
            let stream = (sourceNum === 1) ? stream1 : stream2;

            if (stream) {
                stream.getTracks().forEach(track => track.stop());
            }
            video.srcObject = null;
            if (sourceNum === 1) stream1 = null;
            else stream2 = null;
            status.textContent = '未選択';
        }
        
        function drawPlaceholder(x, y, w, h, text) {
            ctx.fillStyle = '#2d3748';
            ctx.fillRect(x, y, w, h);
            ctx.fillStyle = 'white';
            ctx.font = '24px "Inter"';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(text, x + w / 2, y + h / 2);
        }

        function drawVideoWithAspectRatio(video, x, y, w, h) {
             if (video.videoWidth === 0) {
                 drawPlaceholder(x, y, w, h, "表示不可: 別の画面を選択してください");
                 return;
             }
            const videoAspect = video.videoWidth / video.videoHeight;
            const canvasAspect = w / h;
            let drawWidth, drawHeight, offsetX, offsetY;

            if (videoAspect > canvasAspect) {
                drawWidth = w;
                drawHeight = drawWidth / videoAspect;
                offsetX = x;
                offsetY = y + (h - drawHeight) / 2;
            } else {
                drawHeight = h;
                drawWidth = drawHeight * videoAspect;
                offsetX = x + (w - drawWidth) / 2;
                offsetY = y;
            }
            ctx.drawImage(video, offsetX, offsetY, drawWidth, drawHeight);
        }

        function drawCanvas() {
            ctx.fillStyle = '#1a202c';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            if (currentLayout === 'side-by-side') {
                const halfWidth = canvas.width / 2;
                if (stream1) drawVideoWithAspectRatio(video1, 0, 0, halfWidth, canvas.height);
                else drawPlaceholder(0, 0, halfWidth, canvas.height, 'ソース1を選択');
                
                if (stream2) drawVideoWithAspectRatio(video2, halfWidth, 0, halfWidth, canvas.height);
                else drawPlaceholder(halfWidth, 0, halfWidth, canvas.height, 'ソース2を選択');

                ctx.fillStyle = '#4a5568';
                ctx.fillRect(halfWidth - 1, 0, 2, canvas.height);
            } else if (currentLayout === 'pip') {
                const pipWidth = canvas.width * 0.25;
                const pipHeight = pipWidth / (16/9);
                const margin = canvas.width * 0.01;

                if (stream1) drawVideoWithAspectRatio(video1, 0, 0, canvas.width, canvas.height);
                else drawPlaceholder(0, 0, canvas.width, canvas.height, 'ソース1 (背景) を選択');

                if (stream2) {
                    ctx.save();
                    ctx.shadowColor = 'rgba(0, 0, 0, 0.5)';
                    ctx.shadowBlur = 15;
                    drawVideoWithAspectRatio(video2, canvas.width - pipWidth - margin, canvas.height - pipHeight - margin, pipWidth, pipHeight);
                    ctx.strokeStyle = '#4a5568';
                    ctx.lineWidth = 2;
                    ctx.strokeRect(canvas.width - pipWidth - margin, canvas.height - pipHeight - margin, pipWidth, pipHeight);
                    ctx.restore();
                } else {
                     drawPlaceholder(canvas.width - pipWidth - margin, canvas.height - pipHeight - margin, pipWidth, pipHeight, 'ソース2');
                }
            }
            requestAnimationFrame(drawCanvas);
        }

        updateLayoutButtons();
        drawCanvas();
    </script>
</body>
</html>

